---
title: "ğŸŒ€ å‡¦ç†æ™‚é–“ãŒé•·ã„APIã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ãŸã¨ãã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°UIã«ã¤ã„ã¦"
emoji: "ğŸŒ€"
type: "tech"
topics: ["React", "Next.js", "ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°UI", "UX"]
published: true
created_at: "2024-03-31T00:00:00.000Z"
published_at: "2024-03-31T00:00:00.000Z"
---

# å‡¦ç†æ™‚é–“ãŒé•·ã„APIã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ãŸã¨ãã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°UIã«ã¤ã„ã¦

## ğŸ“Œ ä½œã‚ã†ã¨æ€ã£ãŸèƒŒæ™¯

ç”ŸæˆAIã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆAPIã‚’åˆ©ç”¨ã™ã‚‹éš›ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãŒéå¸¸ã«é•·ã„ã“ã¨ãŒãã£ã‹ã‘ã§ã—ãŸã€‚ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã®è¤‡é›‘ãªå‡¦ç†ã«ã‚ˆã‚Šã€APIã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒé…ããªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

ç¾ä»£ã®é–‹ç™ºã§ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ã‚¯ã‚¹ãƒšãƒªã‚¨ãƒ³ã‚¹ï¼ˆUXï¼‰ã®å‘ä¸ŠãŒé‡è¦ã§ã™ã€‚å˜ã«æ©Ÿèƒ½ãŒè±Šå¯Œã§ã‚ã‚‹ã ã‘ã§ãªãã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¿«é©ã«åˆ©ç”¨ã§ãã‚‹ã“ã¨ãŒæ±‚ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

ChatGPTã®DALL-Eã®ç”»åƒç”Ÿæˆãƒ—ãƒ­ã‚»ã‚¹ã¯ã€å„ªã‚ŒãŸãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°UIã®è‰¯ã„ä¾‹ã§ã™ã€‚å‡¦ç†ã«æ™‚é–“ãŒã‹ã‹ã£ã¦ã‚‚ã€é€²è¡ŒçŠ¶æ³ãŒæ˜ç¢ºã«ç¤ºã•ã‚Œã‚‹ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯å®‰å¿ƒã—ã¦å¾…ã¤ã“ã¨ãŒã§ãã¾ã™ã€‚

## ğŸ“Œ ã‚³ãƒ¼ãƒ‰ã«ã¤ã„ã¦

### æº–å‚™

- ä½¿ç”¨æŠ€è¡“:
  - Next.js (14.0.0)
  - React (18.2.0)
  - TailwindCSS

### Streamã®å€¤ã‹ã‚‰ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’èª­ã¿å–ã‚‹ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°UI

#### å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ

- SVGã‚’ä½¿ç”¨ã—ãŸã‚«ã‚¹ã‚¿ãƒ ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ãƒ”ãƒŠãƒ¼
- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ã¦å¤‰åŒ–ã™ã‚‹å††å½¢ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼
- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ãƒ™ãƒ«ã®è¡¨ç¤º

```typescript
// APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¾‹
async function* makeIterator() {
  await sleep(1000)
  yield encoder.encode('{"text":"called"}')
  await sleep(3000)
  yield encoder.encode('{"text":"running"}')
  await sleep(3000)
  yield encoder.encode('{"text":"finished"}')
}

function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms))
}
```

#### ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```tsx
import React, { useState, useEffect } from 'react';

interface LoadingProps {
  status: 'idle' | 'called' | 'running' | 'finished';
  progress?: number;
}

const CircularProgress: React.FC<LoadingProps> = ({ status, progress = 0 }) => {
  const [displayProgress, setDisplayProgress] = useState(0);
  
  // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸé€²è¡Œç‡
  const statusProgress = {
    idle: 0,
    called: 25,
    running: 50,
    finished: 100
  };

  useEffect(() => {
    const targetProgress = progress || statusProgress[status];
    const interval = setInterval(() => {
      setDisplayProgress(prev => {
        if (prev < targetProgress) {
          return Math.min(prev + 2, targetProgress);
        }
        return prev;
      });
    }, 50);

    return () => clearInterval(interval);
  }, [status, progress]);

  const radius = 45;
  const strokeWidth = 8;
  const normalizedRadius = radius - strokeWidth * 2;
  const circumference = normalizedRadius * 2 * Math.PI;
  const strokeDasharray = `${circumference} ${circumference}`;
  const strokeDashoffset = circumference - (displayProgress / 100) * circumference;

  const statusLabels = {
    idle: 'å¾…æ©Ÿä¸­',
    called: 'APIå‘¼ã³å‡ºã—ä¸­',
    running: 'å‡¦ç†å®Ÿè¡Œä¸­',
    finished: 'å®Œäº†'
  };

  const statusColors = {
    idle: 'text-gray-500',
    called: 'text-blue-500',
    running: 'text-yellow-500',
    finished: 'text-green-500'
  };

  return (
    <div className="flex flex-col items-center justify-center space-y-4">
      <div className="relative">
        <svg
          height={radius * 2}
          width={radius * 2}
          className="transform -rotate-90"
        >
          {/* èƒŒæ™¯ã®å†† */}
          <circle
            stroke="currentColor"
            className="text-gray-200"
            fill="transparent"
            strokeWidth={strokeWidth}
            r={normalizedRadius}
            cx={radius}
            cy={radius}
          />
          {/* é€²è¡ŒçŠ¶æ³ã‚’ç¤ºã™å†† */}
          <circle
            stroke="currentColor"
            className={`transition-all duration-500 ${
              status === 'finished' ? 'text-green-500' : 'text-blue-500'
            }`}
            fill="transparent"
            strokeWidth={strokeWidth}
            strokeDasharray={strokeDasharray}
            style={{ strokeDashoffset }}
            strokeLinecap="round"
            r={normalizedRadius}
            cx={radius}
            cy={radius}
          />
        </svg>
        
        {/* ä¸­å¤®ã®ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸è¡¨ç¤º */}
        <div className="absolute inset-0 flex items-center justify-center">
          <span className="text-lg font-semibold text-gray-700">
            {Math.round(displayProgress)}%
          </span>
        </div>
      </div>
      
      {/* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ãƒ™ãƒ« */}
      <div className={`text-sm font-medium ${statusColors[status]}`}>
        {statusLabels[status]}
      </div>
      
      {/* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */}
      {status !== 'finished' && status !== 'idle' && (
        <div className="flex space-x-1">
          <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
          <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
          <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
        </div>
      )}
    </div>
  );
};
```

### ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°APIã¨ã®é€£æº

```tsx
const LoadingDemo: React.FC = () => {
  const [status, setStatus] = useState<'idle' | 'called' | 'running' | 'finished'>('idle');
  const [isLoading, setIsLoading] = useState(false);

  const handleApiCall = async () => {
    setIsLoading(true);
    setStatus('idle');

    try {
      const response = await fetch('/api/stream-status');
      const reader = response.body?.getReader();
      
      if (!reader) return;

      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        const chunk = new TextDecoder().decode(value);
        try {
          const data = JSON.parse(chunk);
          setStatus(data.text);
        } catch (e) {
          // JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
          console.warn('Failed to parse chunk:', chunk);
        }
      }
    } catch (error) {
      console.error('API call failed:', error);
      setStatus('idle');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="max-w-md mx-auto p-6 bg-white rounded-lg shadow-lg">
      <h2 className="text-xl font-bold text-center mb-6">
        APIå‡¦ç†çŠ¶æ³
      </h2>
      
      <CircularProgress status={status} />
      
      <div className="mt-6 space-y-2">
        <button
          onClick={handleApiCall}
          disabled={isLoading}
          className="w-full py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          {isLoading ? 'å‡¦ç†ä¸­...' : 'APIå®Ÿè¡Œ'}
        </button>
        
        {status === 'finished' && (
          <div className="p-3 bg-green-100 text-green-700 rounded-lg text-center">
            å‡¦ç†ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸï¼
          </div>
        )}
      </div>
    </div>
  );
};
```

### Route Handlerï¼ˆAPIå´ï¼‰ã®å®Ÿè£…

```typescript
// app/api/stream-status/route.ts
import { NextRequest } from 'next/server';

export async function GET(request: NextRequest) {
  const encoder = new TextEncoder();
  
  const stream = new ReadableStream({
    async start(controller) {
      try {
        // ã‚¹ãƒ†ãƒƒãƒ—1: APIå‘¼ã³å‡ºã—é–‹å§‹
        await sleep(1000);
        controller.enqueue(encoder.encode('{"text":"called"}\n'));
        
        // ã‚¹ãƒ†ãƒƒãƒ—2: å‡¦ç†å®Ÿè¡Œä¸­
        await sleep(3000);
        controller.enqueue(encoder.encode('{"text":"running"}\n'));
        
        // ã‚¹ãƒ†ãƒƒãƒ—3: å‡¦ç†å®Œäº†
        await sleep(3000);
        controller.enqueue(encoder.encode('{"text":"finished"}\n'));
        
        controller.close();
      } catch (error) {
        controller.error(error);
      }
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/plain; charset=utf-8',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

## ğŸ“Œ UXã®æ”¹å–„ãƒã‚¤ãƒ³ãƒˆ

### 1. é€²è¡ŒçŠ¶æ³ã®å¯è¦–åŒ–

- **é€²è¡Œç‡ã®è¡¨ç¤º**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã©ã®ç¨‹åº¦å®Œäº†ã—ãŸã‹ã‚’æŠŠæ¡ã§ãã‚‹
- **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ãƒ™ãƒ«**: ç¾åœ¨ä½•ãŒè¡Œã‚ã‚Œã¦ã„ã‚‹ã‹ã‚’æ˜ç¢ºã«ç¤ºã™
- **è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯**: è‰²ã‚„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§çŠ¶æ…‹ã‚’è¡¨ç¾

### 2. äºˆæƒ³ã•ã‚Œã‚‹å¾…æ©Ÿæ™‚é–“ã®è¡¨ç¤º

```tsx
const estimatedTimes = {
  called: 'ç´„30ç§’',
  running: 'ç´„2åˆ†',
  finished: 'å®Œäº†'
};

// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã§ä½¿ç”¨
<div className="text-xs text-gray-500 mt-2">
  äºˆæƒ³æ™‚é–“: {estimatedTimes[status]}
</div>
```

### 3. ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ©Ÿèƒ½ã®å®Ÿè£…

```tsx
const [abortController, setAbortController] = useState<AbortController | null>(null);

const handleCancel = () => {
  if (abortController) {
    abortController.abort();
    setStatus('idle');
    setIsLoading(false);
  }
};

// APIã‚³ãƒ¼ãƒ«æ™‚
const controller = new AbortController();
setAbortController(controller);

const response = await fetch('/api/stream-status', {
  signal: controller.signal
});
```

### 4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```tsx
const [error, setError] = useState<string | null>(null);

// ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã®è¡¨ç¤º
{error && (
  <div className="p-3 bg-red-100 text-red-700 rounded-lg text-center">
    ã‚¨ãƒ©ãƒ¼: {error}
  </div>
)}
```

## ğŸ“ ã¾ã¨ã‚

é•·æ™‚é–“ã®APIå‡¦ç†ã«ãŠã„ã¦ã€é©åˆ‡ãªãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°UIã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ï¼š

âœ… **ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä¸å®‰ã‚’è»½æ¸›**: é€²è¡ŒçŠ¶æ³ãŒåˆ†ã‹ã‚‹ã“ã¨ã§å®‰å¿ƒæ„Ÿã‚’æä¾›
âœ… **é›¢è„±ç‡ã®æ”¹å–„**: å¾…æ©Ÿæ™‚é–“ä¸­ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“å‘ä¸Š
âœ… **é€æ˜æ€§ã®å‘ä¸Š**: å‡¦ç†ã®å„æ®µéšã‚’æ˜ç¢ºã«è¡¨ç¤º
âœ… **ã‚¨ãƒ©ãƒ¼å¯¾å¿œ**: å•é¡Œç™ºç”Ÿæ™‚ã®é©åˆ‡ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

ç‰¹ã«ç”ŸæˆAIã‚„ãƒ‡ãƒ¼ã‚¿å‡¦ç†ç³»ã®APIã§ã¯ã€å‡¦ç†æ™‚é–“ãŒäºˆæ¸¬ã—ã«ãã„ãŸã‚ã€ã“ã†ã—ãŸãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°UIã®é‡è¦æ€§ãŒã‚ˆã‚Šé«˜ã¾ã‚Šã¾ã™ã€‚

ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«çŠ¶æ³ã‚’æ›´æ–°ã§ãã€ã‚ˆã‚Šè‰¯ã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’æä¾›ã§ãã¾ã™ã€‚